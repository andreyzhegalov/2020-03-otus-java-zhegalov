# Показатели GC
1. Throthout
2. Latency
3.???? 

Наиболее простым для моделирования и исследования является Throthout, так как носит интегральных характер. 
В домашнем задании GC сравниваются по данному показателю.

# Модель

Был смоделирован сервис, принимающий и обрабатывающий некоторый поток обращений.
Технически сервис представлен АТД типа очередь.
Допущения:
1. Динамический аспект не моделировался. В один момент времени модель освобождает очередь (отрабатывает обращения) и  загружает новый блок обращений.
2. Каждое обращение одинково ресурсоемко. Моделируется только затраты памяти, так как это соответвует задаче иследования сборищиков мусора.
3. Период обработки сообщений постоянен.

Настройки:
1. Производительность (ratio) - отношение количества поступивших обращений к выполненым. Для удобства понимания реализована следующая логика: ratio = 1, кода все что поступило отработалось. ratio > 1, когда поступает больше чем отрабатывается, ratio < 1, когда отрабатываетсся больше, чем поступило.
2. Количество поступающих заявок
3. "Стоимость" обращения. Затраты памяти.
4. Частота срабаатываний
5. Начальное количество обращений в системе. Позволяет моделировать многократную обработку заявки. То есть при ratio < 0, не все обращения будут сразу выходить из очереди.

В исследовании GC использовалось изменение только ratio (0.1-1.9). Остальные параметры подобраны так, чтобы при ratio ~= 2 OutOfMemoryError не наступало сразу.

Особенности:
В моделе в каждом цикле работы с очередью выполняется изменений сотояния элементов (инкремент состояния). Это изменяет количество обрещений к объекту и оеспечивается переход в область OldGeneration.

Технические характеристики стенда:
1. Intel(R) Core(TM) i7-2670QM CPU @ 2.20GHz
2. 8GB DDR3 Synchronous 1333 MHz (0,8 ns)
3. OS Linux Mint 19 Tara

Пример запуска приложения для ParallelGC и ratio=1.0:
java  -XX:+UseParallelGC -Xms256M -Xmx256M  -Xlog:gc=info:file=./logs/name.log:tags,uptime,time,level:filecount=5,filesize=10m hw04.gc.AppModel 1.0

**Распределения пауз GC для различных ratio ( причина паузы не рассматривалась )**

Диаграммы представлены "ящиками с усами" (линк)

При ratio=0.6
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_06.png?raw=true)
При ratio=1.0
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_10.png?raw=true)
При ratio=1.5
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_15.png?raw=true)
При ratio=1.9
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_19.png?raw=true)
**Выводы**
1. При малых нагрузках (ratio = 0.6) среднее значение пауз у "простых" сборщиков (не G1) получается даже меньше. 
2. При нагрузках соимеримых с производительностью (ratio = 1.0) последовательный сборщих начинает уступать по оперативности.
3. При нагрузках бОльших возможной производительности (ratio = 1.5, 1.9) паузы у G1 в среднем гораздо меньше у Serial и Parallel. Оперативность Serial и Parallel примерно одинаковая.

**Продолжительность работы приложения**
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/working_time.png?raw=true)
**Выводы**
1. При небольших превышениях нагрузки (ratio=1.1) G1 обеспечил наибольшую продолжительность работы приложения до OutOfMemoryError Exception.
2. При бОльших нагрузках время работы приложения с разными GC примерно соизмеримо.

**Процент работы GC (логарифмический масштаб)**
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/latency.png?raw=true)

Показано процентное отношение суммы всех пауз GC к общей продолжительности работы.
**Выводы**
1. При малых нагрузках (ratio = 0.6) Parallel GC меньше всего исопользовал полезного ресурса. 
2. При нагрузках бОльших возможной производительности (ratio = 1.5, 1.9) G1 исопльзовал больше всего полезного ресурса. То есть, несмотря на минимальные паузы останова приложения их количество было большим. Остальные сборщики вели себя примерно одинаково.


При нагрузках бОльших возможной производительности (ratio = 1.5, 1.9)
Можно сделать вывод, что G1 при таких условиях обеспечивает наилучшее время отклика (latency), но наихудшую производительность приложения.

Основной вывод 
Результативоность работы  GC звисит от особенностей приложения, целевого показателя и выделенных ресурсов. С этой точки зрений нет наиличших и наихудший, есть локально оптимальный GC.
