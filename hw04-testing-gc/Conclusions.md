# Основные показатели производительности GC
1. Throughput - объем вычислительный ресурсов, затрачиваемых GC. Влияет на производительность.
2. Latency - время прерывания работы приложения. Влияет на скорость отклика.
3. Footprint - объем используемой памяти.

Для сравнения производительности разных алгоритмов GC будем использовать интегральную оценку throughout. Это проще всего смоделировать. В качестве оцениваемого ресурса будет выступать общее количество времени,  затраченное на сборку мусора.
```
throughout = 100 *  GC work time / app work time [%]
```
Время работы приложения будет фиксированным для случаев без OutOfMemoryError.

# Модель

Для исследования работы разных GC был смоделирован сервис, принимающий и обрабатывающий некоторый поток обращений.
Технически сервис представлен АТД типа очередь.

Допущения:
1. Динамический аспект не моделировался. Обращения поступают пачкой. В один момент времени модель освобождает очередь (отрабатывает обращения) и  загружает новый блок обращений.
2. Каждое обращение одинаково ресурсоемко. Моделируется только затраты памяти.
3. Период работы с очередью постоянен.

Параметры настройки:
1. Производительность приложения (ratio) - отношение количества поступивших обращений к выполненным. Реализована следующая логика: ratio = 1, кода все что поступило отработалось. ratio > 1, когда поступает больше чем отрабатывается, ratio < 1, когда отрабатывается больше, чем поступило.
2. Количество поступающих заявок
3. "Стоимость" обращения. Затраты памяти на объект, моделирующий обращение.
4. Частота срабатываний. Период приема, выполнения, обработки обращения.
5. Начальное количество обращений в системе. Позволяет моделировать некоторую работу с обращением.

В исследовании GC использовалось изменение только ratio (0.1-1.9). Остальные параметры подобраны так, чтобы при ratio ~= 2 OutOfMemoryError настуала через несколько минут после начала работы.

В каждом цикле работы с очередью в модели выполняется некоторая работа с каждым обращением. Технически это цикл по элементам очереди с инкрементом их состояния. Это изменяет количество обращений к объекту и обеспечивается переход объекта между областями heap.

Технические характеристики стенда:
1. Intel(R) Core(TM) i7-2670QM CPU @ 2.20GHz
2. 8GB DDR3 1333 MHz (0,8 ns)
3. OS Linux Mint 19 Tara

Пример запуска приложения для parallel-gc и ratio=1.0:
```bash
java  -XX:+UseParallelGC -Xms256M -Xmx256M -Xlog:gc=info:file=./logs/name.log:tags,uptime,time,level:filecount=5,filesize=10m hw04.gc.AppModel 1.0
```

### Распределения интервалов работы GC 
Тип паузы не исследовался. Оценка велась при различных отношениях ratio. В качестве представления выбран ["ящик с усами"](https://ru.wikipedia.org/wiki/%D0%AF%D1%89%D0%B8%D0%BA_%D1%81_%D1%83%D1%81%D0%B0%D0%BC%D0%B8).
###### Распределение интервалов работы GC при ratio=0.6
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_06.png?raw=true)
###### Распределение интервалов работы GC при ratio=1.0
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_10.png?raw=true)
###### Распределение интервалов работы GC при ratio=1.5
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_15.png?raw=true)
###### Распределение интервалов работы GC при ratio=1.9
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/boxplot_19.png?raw=true)
**Выводы по распределению интервалов**
1. При малых нагрузках (ratio = 0.6) среднее значение пауз у "простых" сборщиков (не G1) получилось даже меньше. Возможно сказывается, то что удаление не фрагментированной области памяти проще чем выполнение алгоритма G1. 
2. При нагрузках соизмеримых с производительностью (ratio = 1.0) serial-gc начинает уступать по оперативности.
3. При нагрузках, превышающих производительность приложения (ratio = 1.5, 1.9) интервалы работы у G1 в среднем гораздо меньше, чем у serial и parallel. Интервалы работы serial и parallel в среднем примерно одинаковые. То есть, G1 , обеспечивает наилучшее время отклика (latency).

### Продолжительность работы приложения
Интерес представляют только случаи при ratio > 1. При ratio <= 1 время работы не ограничивается OutOfMemoryError.
![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/working_time.png?raw=true)
**Выводы**
1. При небольших превышениях нагрузки (ratio=1.1) G1 обеспечил наибольшую продолжительность работы приложения до OutOfMemoryError.
2. При бОльших нагрузках время работы приложения с разными GC примерно соизмеримо. 

### Интегральная оценка затрат производительности на  GC
*(логарифмический масштаб)

![](https://github.com/andreyzhegalov/2020-03-otus-java-zhegalov/blob/feature/hw04-testing-gc/hw04-testing-gc/pic/throughput.png?raw=true)

**Выводы**
1. При малых нагрузках (ratio = 0.6) parallel-gc меньше всего использовал ресурса JVM. 
2. При нагрузках бОльших возможной производительности (ratio = 1.5, 1.9) G1 больше всех использовал ресурс JVM. То есть, несмотря на минимальные паузы останова приложения их количество было большим. Остальные сборщики вели себя примерно одинаково.
3. При нагрузках бОльших возможной производительности (ratio = 1.5, 1.9) G1 обеспечивает наилучшее время отклика (latency), но использует больше ресурса JVM.

### Основной вывод 
Результативность работы  GC зависит от особенностей приложения, целевого показателя и выделенных ресурсов. С этой точки зрения нет наилучших и наихудший, есть локально оптимальный GC.
Для приведенной простой модели и малых нагрузках использование serial-gc оказалось даже более эффективно.
